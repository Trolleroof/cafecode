## **Phase 1: Foundation & Abstractions**

### 1. **User Authentication**
- Use Supabase (or your auth provider) to ensure every request is associated with a unique, authenticated user ID.

### 2. **Abstract User Workspace Management**
- Create a module/class (e.g., `UserWorkspaceManager`) that:
  - Given a user ID, returns the absolute path to their workspace (e.g., `/workspaces/{userId}`).
  - Handles creation of the workspace directory if it doesn‚Äôt exist.
- **Why?**  
  - Later, you can swap this to return a container endpoint or remote path instead of a local directory.

### 3. **Abstract File Operations**
- All file operations (read, write, delete, list) should go through a single interface (e.g., `UserFileService`).
- This service:
  - Accepts a user ID and a relative file path.
  - Validates that the resolved path is within the user‚Äôs workspace.
  - Performs the file operation.
- **Why?**  
  - Later, you can swap this to call a remote API or container instead of the local filesystem.

---

## **Phase 2: Terminal & Shell Management**

### 4. **Abstract Shell/Terminal Spawning**
- When a user requests a terminal:
  - Use a `UserTerminalManager` to spawn a shell process with `node-pty`.
  - Set the working directory to the user‚Äôs workspace.
  - Store a mapping of user ID ‚Üí shell process.
- **Why?**  
  - Later, you can swap this to connect to a shell inside a user‚Äôs container.

---

## **Phase 3: Path Validation & Security**

### 5. **Strict Path Validation**
- In `UserFileService`, always resolve and check that the requested path is inside the user‚Äôs workspace.
- Reject any operation that tries to escape (e.g., contains `..` or is absolute).

### 6. **API Security**
- All backend endpoints must:
  - Authenticate the user.
  - Only allow file/terminal operations for the authenticated user‚Äôs workspace.

---

## **Phase 4: Dockerization & Deployment**

### 7. **Dockerize the Backend**
- Add a `Dockerfile` for your backend.
- Test locally, then deploy to your chosen platform (Render, Fly.io, DigitalOcean, AWS ECS, etc.).

---

## **Phase 5: Frontend Integration**

### 8. **Frontend API Calls**
- All file and terminal API calls should include the user‚Äôs session token.
- Use an environment variable for the backend API URL.

---

## **Phase 6: Monitoring & Resource Management**

### 9. **Logging & Monitoring**
- Log all file and terminal operations (with user ID).
- Monitor for suspicious activity (e.g., repeated path validation failures).

### 10. **Resource Limits**
- Set container-level CPU/memory limits.
- (Optional) Monitor per-user resource usage.

---

## **Phase 7: Future-Proofing for Per-User Containers**

### 11. **Keep All User Logic Modular**
- All user-specific logic (file ops, shell spawning) should be behind interfaces/classes.
- Document these interfaces so they can be swapped for containerized implementations later.

### 12. **Prepare for Migration**
- When ready, you can:
  - Swap `UserWorkspaceManager` to return a container endpoint.
  - Swap `UserFileService` and `UserTerminalManager` to interact with per-user containers.
  - üöÄ **Planned:** Terminal sessions will run inside per-user containers for full isolation.

---

# **Summary Table**

| Step                        | What to Do                                      | Status                | Notes                                      |
|-----------------------------|-------------------------------------------------|-----------------------|--------------------------------------------|
| Auth                        | Use Supabase/user ID                            | ‚úÖ Implemented        | Supabase + RLS + frontend                  |
| UserWorkspaceManager        | Abstract workspace path logic                   | ‚úÖ Implemented        | backend/services/UserWorkspaceManager.js    |
| UserFileService             | Abstract file ops + path validation             | ‚úÖ Implemented        | backend/services/UserFileService.js         |
| UserTerminalManager         | Abstract shell spawning                         | ‚úÖ Implemented        | backend/services/UserTerminalManager.js     |
| Path validation             | Enforce per-user directory                      | ‚úÖ Implemented        | UserFileService.resolveUserPath             |
| API security                | Auth on all endpoints                           | ‚ö†Ô∏è Partial           | Some routes may need stricter checks        |
| Dockerize                   | Add Dockerfile, deploy                          | ‚ùå Not done           | No Dockerfile yet                           |
| Frontend integration        | Use env var for API URL, send session token     | ‚úÖ Implemented        | WebSocket and API calls                     |
| Logging/monitoring          | Log ops, monitor for abuse                      | ‚ö†Ô∏è Partial           | Some logging, needs more monitoring         |
| Resource limits             | Set container limits                            | ‚ö†Ô∏è Partial           | Docker exec has limits, backend not set     |
| Modular code                | Keep user logic behind interfaces               | ‚úÖ Implemented        | All user logic modular                      |
| Terminal containerization   | Run terminal in per-user container              | üöÄ Planned            | To be implemented for isolation             |

---


MAKE SURE TO UPDATE THIS PLAN EVERY TIME WE FINISH A MILESTONE


MAKE SURE TO UPDATE THIS PLAN EVERY TIME WE FINISH A MILESTONE